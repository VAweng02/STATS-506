---
title: "STATS 506 - Homework 2"
author: "Vincent Weng"
format:
  html:
    embed-resources: true
---

<h3>Problem 1 - Dice Game</h3>

Part (A) - Version 1: Implement this game using a loop.
```{r}
#' Dice Game Version 1: Using a loop
#' @description Plays a dice game
#' @param num_rolls: Number of dice to roll
#' @return total_winnings: Total winnings after accumulating wins and losses for the game
play_dice1 <- function(num_rolls) {
  total_winnings <- 0
  for (i in 1:num_rolls) {
    total_winnings <- total_winnings -2 
    roll <- sample(1:6, 1, replace = TRUE)
    if (roll == 3) {
      total_winnings <- total_winnings + 6
    } else if (roll == 5) {
      total_winnings <- total_winnings + 10
    }
  }
  return(total_winnings)
}
```


Part (A) - Version 2: Implement this game using built-in R vectorized functions.
```{r}
#' Dice Game Version 2: Using built-in R vectorized functions
#' @description Plays a dice game
#' @param num_rolls: Number of dice to roll
#' @return total_winnings: Total winnings after accumulating wins and losses for the game
play_dice2 <- function(num_rolls) {
  rolls <- sample(1:6, num_rolls, replace = TRUE)
  total_winnings <- ifelse(rolls == 3 | rolls == 5, 2 * rolls, 0)
  total_winnings <- sum(total_winnings) - (2*num_rolls)
  return(total_winnings)
}
```


Part (A) - Version 3: Implement this by rolling all the dice into one and collapsing the die rolls into a single table()
```{r}
#' Dice Game Version 3: By rolling all dice into one and collapsing die rolls into single table()
#' @description Plays a dice game
#' @param num_rolls: Number of dice to roll
#' @return total_winnings: Total winnings after accumulating wins and losses for the game
play_dice3 <- function(num_rolls) {
  dice_rolls <- table(factor(sample(1:6, num_rolls, replace=TRUE), levels=1:6))
  table <- dice_rolls[3]*6 + dice_rolls[5]*10 - 2*num_rolls
  return(table)
}
```


Part (A) - Version 4: Implement this game by using one of the “apply” functions
```{r}
#' Dice Game Version 4: By using one of the “apply” functions
#' @description Plays a dice game
#' @param num_rolls: Number of dice to roll
#' @return total_winnings: Total winnings after accumulating wins and losses for the game
play_dice4 <- function(num_rolls) {
  dice_rolls <- sample(1:6, num_rolls, replace=TRUE)
    
  return(-2*num_rolls + sum(vapply(dice_rolls, function(roll) {
    if (roll == 3 | roll == 5) {
      return(2*roll)
    } else {
      return(0)
    }
  }, 1)))
}
```


Part (B) - Demonstrate that all versions work. Do so by running each a few times, once with an input a 3, and once with an input of 3,000
```{r}
# Print results for play_dice1
cat("Results for play_dice1:\n",
    "Score with 3 rolls:", play_dice1(3), "\n",
    "Score with 3000 rolls:", play_dice1(3000), "\n\n")

# Print results for play_dice2
cat("Results for play_dice2:\n",
    "Score with 3 rolls:", play_dice2(3), "\n",
    "Score with 3000 rolls:", play_dice2(3000), "\n\n")

# Print results for play_dice3
cat("Results for play_dice3:\n",
    "Score with 3 rolls:", play_dice3(3), "\n",
    "Score with 3000 rolls:", play_dice3(3000), "\n\n")

# Print results for play_dice4
cat("Results for play_dice4:\n",
    "Score with 3 rolls:", play_dice4(3), "\n",
    "Score with 3000 rolls:", play_dice4(3000), "\n")

```


Part (C) - Demonstrate that the four versions give the same result. Test with inputs 3 and 3,000. (You will need to add a way to control the randomization.)
```{r}
#' Dice Game Version 1: Using a loop
#' @description Plays a dice game
#' @param num_rolls: Number of dice to roll
#' @param seed: Sets a seed (NULL if not provided)
#' @return total_winnings: Total winnings after accumulating wins and losses for the game
play_dice1 <- function(num_rolls, seed = NULL) {
  set.seed(seed)
  total_winnings <- 0
  for (i in 1:num_rolls) {
    total_winnings <- total_winnings -2 
    roll <- sample(1:6, 1, replace = TRUE)
    if (roll == 3) {
      total_winnings <- total_winnings + 6
    } else if (roll == 5) {
      total_winnings <- total_winnings + 10
    }
  }
  return(total_winnings)
}


#' Dice Game Version 2: Using built-in R vectorized functions
#' @description Plays a dice game
#' @param num_rolls: Number of dice to roll
#' @param seed: Sets a seed (NULL if not provided)
#' @return total_winnings: Total winnings after accumulating wins and losses for the game
play_dice2 <- function(num_rolls, seed = NULL) {
  set.seed(seed)
  rolls <- sample(1:6, num_rolls, replace = TRUE)
  total_winnings <- ifelse(rolls == 3 | rolls == 5, 2 * rolls, 0)
  total_winnings <- sum(total_winnings) - (2*num_rolls)
  return(total_winnings)
}


#' Dice Game Version 3: By rolling all dice into one and collapsing die rolls into single table()
#' @description Plays a dice game
#' @param num_rolls: Number of dice to roll
#' @param seed: Sets a seed (NULL if not provided)
#' @return total_winnings: Total winnings after accumulating wins and losses for the game
play_dice3 <- function(num_rolls, seed = NULL) {
  set.seed(seed)
  dice_rolls <- table(factor(sample(1:6, num_rolls, replace=TRUE), levels=1:6))
  table <- dice_rolls[3]*6 + dice_rolls[5]*10 - 2*num_rolls
  return(table)
}


#' Dice Game Version 4: By using one of the “apply” functions
#' @description Plays a dice game
#' @param num_rolls: Number of dice to roll
#' @param seed: Sets a seed (NULL if not provided)
#' @return total_winnings: Total winnings after accumulating wins and losses for the game
play_dice4 <- function(num_rolls, seed = NULL) {
  set.seed(seed)
  dice_rolls <- sample(1:6, num_rolls, replace=TRUE)
    
  return(-2*num_rolls + sum(vapply(dice_rolls, function(roll) {
    if (roll == 3 | roll == 5) {
      return(2*roll)
    } else {
      return(0)
    }
  }, 1)))
}


# Print results for play_dice1
cat("Results for play_dice1:\n",
    "Score with 3 rolls:", play_dice1(3, seed = 111), "\n",
    "Score with 3000 rolls:", play_dice1(3000, seed = 111), "\n\n")

# Print results for play_dice2
cat("Results for play_dice2:\n",
    "Score with 3 rolls:", play_dice2(3, seed = 111), "\n",
    "Score with 3000 rolls:", play_dice2(3000, seed = 111), "\n\n")

# Print results for play_dice3
cat("Results for play_dice3:\n",
    "Score with 3 rolls:", play_dice3(3, seed = 111), "\n",
    "Score with 3000 rolls:", play_dice3(3000, seed = 111), "\n\n")

# Print results for play_dice4
cat("Results for play_dice4:\n",
    "Score with 3 rolls:", play_dice4(3, seed = 111), "\n",
    "Score with 3000 rolls:", play_dice4(3000, seed = 111), "\n")

```


Part(D) - Use the microbenchmark package to clearly demonstrate the speed of the implementations. Compare performance with a low input (1,000) and a large input (100,000). Discuss the results
```{r}
library(microbenchmark)
microbenchmark(loop = play_dice1(1000, seed = 111),
               vectorized = play_dice2(1000, seed = 111),
               table = play_dice3(1000, seed = 111),
               apply = play_dice3(1000, seed = 111))
```

Part(E) - Do you think this is a fair game? Defend your decision with evidence based upon a Monte Carlo simulation.
```{r}
reps <- 10000
sim <- vector(length=reps)
for (i in 1:reps) {
  sim[i] <- play_dice2(1000)
}
hist(sim)
abline(v=mean(save), col='red')
```
This not a fair game, because the Monte Carlo simluation shows that the expected value (average outcome) of the game is not equal to zero.




<h3>Problem 2 - Linear Regression</h3>

Part(A) - The names of the variables in this data are way too long. Rename the columns of the data to more reasonable lengths.
```{r}
cars_data <- read.csv("cars.csv")

colnames(cars_data) <- c("dim_height", "dim_length", "dim_width", "eng_drive_line", "eng_type", "eng_hybrid", "eng_num_gears", "eng_transmission", "fuel_city_mpg", "fuel_type", "fuel_highway_mpg", "id_class", "id", "id_make", "id_model_year", "id_year", "eng_horsepower", "eng_torque")
```


Part(B) - Restrict the data to cars whose Fuel Type is “Gasoline”.
```{r}
gasoline_cars <- cars_data[cars_data$fuel_type == "Gasoline", ]
```


Part(C) - Examine the distribution of highway gas mileage. Consider whether a transformation could be used. If so, generate the transformed variable and use this variable going forward. If not, provide a short justification.
```{r}
# highway gas mileage of 223 was removed (outlier)
gasoline_cars <- gasoline_cars[gasoline_cars$fuel_city_mpg < 50, ]

summary(gasoline_cars$fuel_city_mpg)

hist(gasoline_cars$fuel_city_mpg, breaks = 25, main = "Distribution of highway gas mileage", xlab = "highway gas mileage", col = "blue")
```
Part(D) - Fit a linear regression model predicting MPG on the highway. The predictor of interest is torque. Control for:

- The horsepower of the engine
- All three dimensions of the car
- The year the car was released, as a categorical variable.

Briefly discuss the estimated relationship between torque and highway MPG. Be precise about the interpretation of the estimated coefficient.
```{r}
model <- lm(fuel_highway_mpg ~ eng_torque + eng_horsepower + dim_length + dim_width + dim_height + as.factor(id_year), data = gasoline_cars)
summary(model)
```

Part(E) - It seems reasonable that there may be an interaction between torque and horsepower. Refit the model (with lm) and generate an interaction plot, showing how the relationship between torque and MPG changes as horsepower changes. Choose reasonable values of torque, and show lines for three different reasonable values of horsepower.
```{r}
model <- lm(fuel_highway_mpg ~ eng_torque*eng_horsepower + dim_length + dim_width + dim_height + as.factor(id_year), data = gasoline_cars)

library(interactions)
interact_plot(model, pred = eng_horsepower, modx = eng_torque,at = list(id_year = 2012))
```



